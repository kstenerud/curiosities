                         The Motorola S-Record Format
                         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Author:                 Karl Stenerud (kstenerud@hotmail.com)
Document Revision:      1.1
Creation Date:          March 28, 1999
Last Revision Date:     August 11, 1999



Revision History:
~~~~~~~~~~~~~~~~
0.1 (March 28, 1999):   - Initial document.
0.2 (March 30, 1999):   - Added examples.
                        - Fixed some glaring mistakes.
1.0 (March 31, 1999):   - Added the full-blown example.
                        - Prettied up the document for release.
1.1 (August 11, 1999):  - Discovered S-Record documentation in M68KPRM/AD 1.1


Introduction:
~~~~~~~~~~~~
In this document, I present everything I have discovered about the Motorola
S-Record format.  While I have read Motorola's treatise on S-Record in the
Motorola 68000 programmer's manual, there are still ambiguities present.
This document was born out of frustration due to the lack of solid
information regarding the S-Record format.



Description:
~~~~~~~~~~~
S-Record is a format devised by Motorola to provide a medium which allows
the transfer of binary data from a desktop or mainframe to an embedded
controller or an EPROM burner over a serial link with a 7 bit word size.
(Other data communication mediums are, of course, possible, but the 7 bit
word size caters to almost every form of data communication in use today)

An S-Record is composed entirely of printable ASCII characters (i.e. bit 8 is
always cleared), all of which, aside from the first character in the record
(the ascii character 'S'), represent the hexadecimal values of the bytes
encoded therein.  One byte is represented by 2 ascii characters.
Valid characters are: '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A',
'B', 'C', 'D', 'E', and 'F'.  While it is possible to represent A-F using
lowercase characters, I have thus far only seen systems which encode A-F using
uppercase characters.  Whether this is by convention or decree I cannot say
(Motorola is silent regarding this matter), but it would regardless be prudent
to follow in kind.

At the end of each S-Record, there is most commonly placed some combination of
CR and LF.  Of the sources I found, one of them specified that there
should be at the end of each S-Record a CR and LF, while another assured the
reader that there should only be LF at the end.  The rest remained tactfully
silent regarding this matter.  Though there is much debate as to which
combination forms the One True Line End, the wise programmer would simply
choose to handle all possibilities.
For what it's worth, Motorola states that a line end should be terminated with
a CR.  They also mention a possible "initial field".

Quoted from the Motorola 68000 Family Programmer's Reference Manual (Page C-2):

When downloading S-records, each must be terminated with a CR. Additionally,
an S-record may have an initial field that fits other data such as line
numbers generated by some time-sharing systems. The record length (byte count)
and checksum fields ensure transmission accuracy.




General Format:
~~~~~~~~~~~~~~
           +------------------------+ CHECKSUM
           |                        |
           |       +---------------------------+ COUNT
           |       |                |          |
|---|------|-------|---//----|--//--|----------|------|------|
| S | TYPE | COUNT | ADDRESS | DATA | CHECKSUM | (CR) | (LF) |
|---|------|-------|---//----|--//--|----------|------|------|

Name            Size*   Meaning
~~~~            ~~~~    ~~~~~~~
S:              1       The ascii character 'S'
                        ACCEPTABLE VALUES: S

TYPE:           1       The record type.
                        This determines what kind of record we are dealing
                        with.  An explanation of the individual record types
                        will follow below.
                        ACCEPTABLE VALUES: 0, 1, 2, 3, 5, 7, 8, 9

COUNT:          2       The number of bytes being conveyed by this record.
                        Included in this count are ADDRESS, DATA, and CHECKSUM.
                        Since we are representing one byte with 2 ascii chars,
                        the actual size of the encoded s-record is always
                        COUNT * 2 + 4.
                        As far as I have seen, the trend is for data sizes
                        not exceeding 64 bytes (0x40), even though you could
                        encode a value of 255 (0xFF) in COUNT (which would give
                        a data size of 252 for a TYPE 1 record).
                        ACCEPTABLE VALUES: 00-FF

ADDRESS:        4-8     The address where this data is to be loaded.
                        The size is determined as follows:
                                TYPE = 1 or 9: 2 bytes (16 bit address)
                                TYPE = 2 or 8: 3 bytes (24 bit address)
                                TYPE = 3 or 7: 4 bytes (32 bit address)
                        It seems most likely that once 64 bit addresses become
                        more common among embedded systems, types 4 and 6 will
                        be added to accomodate them.
                        ACCEPTABLE VALUES: any

DATA:           0-504   The data of this record.
                        For compatibility with teletypewriters, some systems
                        may limit this field to as few as 28 bytes (56 chars).
                        ACCEPTABLE VALUES: any

CHECKSUM:       2       This is a checksum of the COUNT, ADDRESS, and
                        DATA fields of the S-Record.
                        You can calculate it by adding the byte values
                        (i.e in their non-encoded form - not encoded into 2
                        ascii chars) of the COUNT, ADDRESS, and DATA fields,
                        and then taking the 1's complement (i.e. subtracting
                        from 255 or inverting all the bits of the sum).
                        ACCEPTABLE VALUES: any

(CR)**          1       ASCII Carriage Return (0x0D).
                        This is an optional field.
                        ACCEPTABLE VALUES: 0x0D

(LF)**          1       ASCII Linefeed (0x0D)
                        This is an optional field.
                        ACCEPTABLE VALUES: 0x0D

*  size represents the number of ascii chars used to encode this field.
   i.e. 2 means 2 chars, which represents 1 encoded byte.

** The carraige return and linefeed characters are used for convenience
   when loading the file into a text editor.  They are optional, but you
   would be far more popular with the programmers if you put them in!
   Many poorly designed text editors will only display text properly if the
   end-of-line markers are in the native format of your operating system.
   The native EOL markers for various operating systems are as follows:
        Macintosh:                      CR only.
        Microsoft operating systems:    CR LF.
        UNIX & derivatives:             LF only.



Record Types:
~~~~~~~~~~~~
TYPE 0: Module Header

          1   1     2      4      ??       2
        |---|---|-------|------|--//--|----------|
        | S | 0 | COUNT | 0000 | DATA | CHECKSUM |
        |---|---|-------|------|--//--|----------|

        This record type marks the beginning of a new module.

        COUNT:          The byte count.
        ADDRESS:        Always 0.
        DATA:           An identifier for this module.
                        I've seen inconsistent assertions of further
                        subdivisions within the DATA field.  However, it
                        appears that most systems simply use DATA as a single
                        field which stores a description of the module.
                        Most systems will make an s-record file with only 1
                        module called "HDR".
        CHECKSUM:       The checksum.

        Example:        The standard "HDR" record:
                                S00600004844521B



TYPE 1: Data record with 2-byte (16-bit) address

          1   1     2        4       ??       2
        |---|---|-------|---------|--//--|----------|
        | S | 1 | COUNT | ADDRESS | DATA | CHECKSUM |
        |---|---|-------|---------|--//--|----------|

        This record type contains data to be loaded into the specified 16-bit
        address.

        COUNT:          The byte count.
        ADDRESS:        The address to load into (2 bytes encoded into 4
                        chars).
        DATA:           The encoded data.
        CHECKSUM:       The checksum.

        Example:        The byte stream 07 06 05 04 03 02 01 00, address 0:
                                S10B00000706050403020100D8




TYPE 2: Data record with 3-byte (24-bit) address

          1   1     2        6       ??       2
        |---|---|-------|---------|--//--|----------|
        | S | 1 | COUNT | ADDRESS | DATA | CHECKSUM |
        |---|---|-------|---------|--//--|----------|

        This record type contains data to be loaded into the specified 16-bit
        address.

        COUNT:          The byte count.
        ADDRESS:        The address to load into (3 bytes encoded into 6
                        chars).
        DATA:           The encoded data.
        CHECKSUM:       The checksum.

        Example:        The byte stream 07 06 05 04 03 02 01 00, address 0:
                                S20C0000000706050403020100D7



TYPE 3: Data record with 4-byte (32-bit) address

          1   1     2        8       ??       2
        |---|---|-------|---------|--//--|----------|
        | S | 1 | COUNT | ADDRESS | DATA | CHECKSUM |
        |---|---|-------|---------|--//--|----------|

        This record type contains data to be loaded into the specified 16-bit
        address.

        COUNT:          The byte count.
        ADDRESS:        The address to load into (4 bytes encoded into 8
                        chars).
        DATA:           The encoded data.
        CHECKSUM:       The checksum.

        Example:        The byte stream 07 06 05 04 03 02 01 00, address 0:
                                S30D000000000706050403020100D6



TYPE 5: Record Count

          1   1     2       4-8         2
        |---|---|-------|---------||----------|
        | S | 1 | COUNT | ADDRESS || CHECKSUM |
        |---|---|-------|---------||----------|

        COUNT:          Since Motorola did not specify how large the ADDRESS
                        field should be for an S5 record, some systems may
                        use 03, 04, or 05 for this field, with the ADDRESS
                        field size adjusted accordingly. Most systems use a
                        COUNT of 05 and an ADRESS field width of 4 bytes.
        ADDRESS:        Holds the number of S1, S2, and S3 records previously
                        transmitted.  The width of this field is determined
                        by the COUNT field.
        DATA:           Not used.
        CHECKSUM        The checksum.

        Example:        A record count of 80:
                                S50500000050AA


TYPE 7: Termination record for type 3 records.

          1   1    2      8          2
        |---|---|----|---------||----------|
        | S | 1 | 05 | ADDRESS || CHECKSUM |
        |---|---|----|---------||----------|

        COUNT:          Always 05
        ADDRESS:        This field may optionally contain a 32-bit address
                        where program control will be transferred to.
        DATA:           Not used.
        CHECKSUM        The checksum.

        Example:        A termination record to start execution at 0x50000002:
                                S70550000002A8



TYPE 8: Termination record for type 2 records.

          1   1    2      6          2
        |---|---|----|---------||----------|
        | S | 1 | 04 | ADDRESS || CHECKSUM |
        |---|---|----|---------||----------|

        COUNT:          Always 04
        ADDRESS:        This field may optionally contain a 24-bit address
                        where program control will be transferred to.
        DATA:           Not used.
        CHECKSUM        The checksum.

        Example:        A termination record to start execution at 0x600010:
                                S8046000108B


TYPE 9: Termination record for type 1 records.

          1   1    2      4          2
        |---|---|----|---------||----------|
        | S | 1 | 03 | ADDRESS || CHECKSUM |
        |---|---|----|---------||----------|

        COUNT:          Always 03
        ADDRESS:        This field may optionally contain a 16-bit address
                        where program control will be transferred to.
        DATA:           Not used.
        CHECKSUM        The checksum.

        Example:        A termination record to start execution at 0x2040:
                                S90320409C



A full-blown example:
~~~~~~~~~~~~~~~~~~~~

S01E00005468652047726561742041636164656D79206F66204C616761646F7C
S1210000496E20746865207363686F6F6C206F6620706F6C69746963616C2070726FD7
S121001E6A6563746F72732049207761732062757420696C6C20656E746572746169AA
S121003C6E65642C0D0A7468652070726F666573736F727320617070656172696E679A
S121005A20696E206D79206A7564676D656E742077686F6C6C79206F7574206F6620BD
S121007874686569720D0A73656E7365732C2077686963682069732061207363656EFD
S1210096652074686174206E65766572206661696C7320746F206D616B65206D6520D0
S12100B46D656C616E63686F6C792E0D0A546865736520756E68617070792070656F37
S12100D2706C6520776572652070726F706F73696E6720736368656D657320666F7288
S12100F02070657273756164696E670D0A6D6F6E617263687320746F2063686F6F73EB
S121010E65206661766F7572697465732075706F6E207468652073636F7265206F668E
S121012C20746865697220776973646F6D2C0D0A63617061636974792C20616E642092
S121014A7669727475653B206F66207465616368696E67206D696E6973746572732043
S1210168746F20636F6E73756C7420746865207075626C69630D0A676F6F643B206FE0
S12101866620726577617264696E67206D657269742C206772656174206162696C694D
S12101A4746965732C20656D696E656E742073657276696365733B206F660D0A696EA6
S12101C2737472756374696E67207072696E63657320746F206B6E6F77207468656978
S12101E072207472756520696E74657265737420627920706C6163696E672069742007
S12101FE6F6E0D0A7468652073616D6520666F756E646174696F6E207769746820741D
S121021C686174206F662074686569722070656F706C653B206F662063686F6F7369D8
S121023A6E6720666F720D0A656D706C6F796D656E747320706572736F6E7320717562
S1210258616C696669656420746F206578657263697365207468656D3B207769746856
S1210276206D616E79206F746865720D0A77696C6420696D706F737369626C652063AE
S121029468696D657261732C2074686174206E6576657220656E746572656420626534
S12102B2666F726520696E746F207468650D0A6865617274206F66206D616E20746FC4
S12102D020636F6E63656976652C20616E6420636F6E6669726D656420696E206D6561
S12102EE20746865206F6C640D0A6F62736572766174696F6E2C207468617420746872
S121030C657265206973206E6F7468696E6720736F206578747261766167616E742099
S121032A616E640D0A6972726174696F6E616C20776869636820736F6D6520706869CA
S12103486C6F736F70686572732068617665206E6F74206D61696E7461696E65642025
S1100366666F720D0A74727574682E0D0AAC
S5050000001EDC
S9030000FC


The first entry is an S0 record, which is a module header.
The byte count is 30 (0x1E), which means that the data portion is 27 bytes.
The address field of an S0 record is always 0000.
The data portion contains the string "The Great Academy of Lagado".
The last 2 characters are the checksum.


The next entries consist of S1 data records, each record containing sequential
addresses in the sense that the next record contains an address of the
previous one plus its data length.  The records were encoded using records
whose data length was 30, giving a byte count of 33 (data length + 1 byte for
checksum + 2 bytes for the 16-bit address since this is an S1 record).

The data that was encoded follows:

In the school of political projectors I was but ill entertained,
the professors appearing in my judgment wholly out of their
senses, which is a scene that never fails to make me melancholy.
These unhappy people were proposing schemes for persuading
monarchs to choose favourites upon the score of their wisdom,
capacity, and virtue; of teaching ministers to consult the public
good; of rewarding merit, great abilities, eminent services; of
instructing princes to know their true interest by placing it on
the same foundation with that of their people; of choosing for
employments persons qualified to exercise them; with many other
wild impossible chimeras, that never entered before into the
heart of man to conceive, and confirmed in me the old
observation, that there is nothing so extravagant and
irrational which some philosophers have not maintained for
truth.


The next record is an S5 record, which is a record count.
The address field contains the count of the data records preceeding it, which,
in this case, is 30 (0x1E).


The final record (since we only made one module in this file) is an S9 record,
which terminates the S1 records preceeding it.
The S9 record contains an execute address of 0000.



Conclusion:
~~~~~~~~~~
Though this explanation of S-Records may appear to be complete, I am quite
sure that I have missed certain aspects of the formats presented above.

If you happen to be a master of the S-Record format, or perhaps you have
access to the archives deep within the belly of Motorola's libraries, I would
greatly appreciate any assistance you could give me on this matter. (I would
be ever more grateful were someone to dig up and send me the official user
and programmer manuals for the M6809 processor, which, alas, do not exist in
Motorola's online electronic libraries as far as I have seen).


== EOT ==
d 