/*
make table for parity

 */



typedef struct
{
	uint pc;	/* Actually Instruction Pointer */
	uint ir;
//	uint ps;	/* processor status */
	uint ax;	/* Accumulator */
	uint bx;	/* Base */
	uint cx;	/* Count */
	uint dx;	/* Data */
	uint cs;	/* Code seg */
	uiny ds;	/* Data seg */
	uint es;	/* Extra seg */
	uint ss;	/* Stack seg */
	uint sp;	/* stack pointer */
	uint bp;	/* base pointer */
	uint si;	/* source index */
	uint di;	/* dest index */

	uint flag_o;	/* 11 overflow */
	uint flag_d;	/* 10 0 = increment, 1 = decrement */
	uint flag_i;	/* 9  interrupt enable */
	uint flag_t;	/* 8  trap flag */
	uint flag_s;	/* 7  sign */
	uint flag_z;	/* 6  zero */
	uint flag_a;	/* 4  auxiliary carry (bit3-bit4) */
	uint flag_p;	/* 2  set if result has even parity */
	uint flag_c;	/* 0  carry */

} i8086_cpu;

/* 1 if even parity */
char parity_table[256] =
{
	1,0,0,1,0,1,1,0,0,1,1,0,1,0,0,1,0,1,1,0,1,0,0,1,1,0,0,1,0,1,1,0,
	0,1,1,0,1,0,0,1,1,0,0,1,0,1,1,0,1,0,0,1,0,1,1,0,0,1,1,0,1,0,0,1,
	0,1,1,0,1,0,0,1,1,0,0,1,0,1,1,0,1,0,0,1,0,1,1,0,0,1,1,0,1,0,0,1,
	1,0,0,1,0,1,1,0,0,1,1,0,1,0,0,1,0,1,1,0,1,0,0,1,1,0,0,1,0,1,1,0,
	0,1,1,0,1,0,0,1,1,0,0,1,0,1,1,0,1,0,0,1,0,1,1,0,0,1,1,0,1,0,0,1,
	1,0,0,1,0,1,1,0,0,1,1,0,1,0,0,1,0,1,1,0,1,0,0,1,1,0,0,1,0,1,1,0,
	1,0,0,1,0,1,1,0,0,1,1,0,1,0,0,1,0,1,1,0,1,0,0,1,1,0,0,1,0,1,1,0,
	0,1,1,0,1,0,0,1,1,0,0,1,0,1,1,0,1,0,0,1,0,1,1,0,0,1,1,0,1,0,0,1
}

unsigned char daa_table[1024] =
{
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x06,0x06,0x06,0x06,0x06,0x06,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x06,0x06,0x06,0x06,0x06,0x06,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x06,0x06,0x06,0x06,0x06,0x06,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x06,0x06,0x06,0x06,0x06,0x06,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x06,0x06,0x06,0x06,0x06,0x06,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x06,0x06,0x06,0x06,0x06,0x06,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x06,0x06,0x06,0x06,0x06,0x06,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x06,0x06,0x06,0x06,0x06,0x06,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x06,0x06,0x06,0x06,0x06,0x06,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x66,0x66,0x66,0x66,0x66,0x66,
	0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x66,0x66,0x66,0x66,0x66,0x66,
	0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x66,0x66,0x66,0x66,0x66,0x66,
	0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x66,0x66,0x66,0x66,0x66,0x66,
	0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x66,0x66,0x66,0x66,0x66,0x66,
	0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x66,0x66,0x66,0x66,0x66,0x66,
	0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x66,0x66,0x66,0x66,0x66,0x66,
	0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x66,0x66,0x66,0x66,0x66,0x66,
	0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x66,0x66,0x66,0x66,0x66,0x66,
	0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x66,0x66,0x66,0x66,0x66,0x66,
	0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x66,0x66,0x66,0x66,0x66,0x66,
	0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x66,0x66,0x66,0x66,0x66,0x66,
	0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x66,0x66,0x66,0x66,0x66,0x66,
	0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x66,0x66,0x66,0x66,0x66,0x66,
	0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x66,0x66,0x66,0x66,0x66,0x66,
	0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x66,0x66,0x66,0x66,0x66,0x66,
	0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x66,0x66,0x66,0x66,0x66,0x66,
	0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x66,0x66,0x66,0x66,0x66,0x66,
	0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x66,0x66,0x66,0x66,0x66,0x66,
	0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x66,0x66,0x66,0x66,0x66,0x66,
	0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x66,0x66,0x66,0x66,0x66,0x66,
	0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x66,0x66,0x66,0x66,0x66,0x66,
	0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x66,0x66,0x66,0x66,0x66,0x66,
	0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,
	0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,
	0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,
	0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,
	0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,
	0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,
	0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,
	0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,
	0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,
	0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x66,0x66,0x66,0x66,0x66,0x66,
	0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,
	0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,
	0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,
	0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,
	0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,
	0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,
	0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,
	0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,
	0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,
	0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,
	0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,
	0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,
	0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,
	0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,
	0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,
	0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,
	0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,
	0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,
	0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,
	0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,
	0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,
	0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66
};

#define ADDRESS_8086(SEG, ADDR) (((SEG<<4) + ADDR)&0xfffff)

/*
fetch instruction: cs:ip
stack op:          ss:sp
variable:          ds,cs,es,ss:<ea>
string source:     ds,cs,es,ss:si
string dest:       es:di
bp as base reg:    ss,cs,ds,es:<ea>

0-3ff reserved for int vectors
ffff0-fffff used for system reset code
f8-ff in i/o space reserved for comm with other intel products

vectors stored as IP/CS pairs:
00: IP - divide error
02: CS
04: IP - single step
06: CS

vectors:
0: divide error (trap)
1: single step (trap)
2: nmi
3: breakpoint
4: overflow
5: array bounds
6: unused opcode
7: ESC opcode
8: timer 0
9: reserved
10: dma0
11: dma1
12: int0
13: int1
14: int2
15: int3
16: numerics
17: reserved
18: timer1
19: timer2
20-31: reserved
32-255: user

nmi is edge triggered and level latched.

exceptions are faults (executed before offending instruction) or traps.

single step trap generated when trap flag set.
not generated after prefix instructions (eg REP), after instructions that modify segment registers, or after WAIT instruction.
vectoring to single-step service routine clears trap flag bit.

int instruction lets you specify type from 0 to 255.  If it is vector of hardware interrupt, bits in interrupt status register are not altered.

*/

void int_ack(uint vector)
{
	uint psw = get_psw();
	push(psw);
	FLAG_T = TFLAG_SET;
	FLAG_I = IFLAG_CLEAR;
	push(SEG_C);
	push(REG_IP);

	vector <<= 2;

	REG_IP = read_16(vector); /* what segment? any? */
	SEG_C = read_16(vector+2);
}


void push(uint value)
{
	REG_SI -= 2;
	write_16(SEG_S, REG_SI, value);
}

uint pull(void)
{
	REG_SI += 2;
	return read_16(SEG_S, REG_SI-2);
}

void reset(void)
{
	REG_CS = 0xffff;
	REG_SS = REG_DS = REG_ES = 0;
	REG_PC = 0;
	set_ps(0xf000);
}


#define EAM_RR_X(OPER, SIZE, REG_S, REG_D)		\
	##OPER(SIZE, REG_S, REG_D)

#define EAM_RM_R(OPER, SIZE, REG_S, MEM_D)		\
	VAR_DST = OPER_##SIZE_##MEM_D();			\
	##OPER(SIZE, REG_S, VAR_DST)

#define EAM_RM_W(OPER, SIZE, REG_S, MEM_D)		\
	EA_DST  = EA_##SIZE_##MEM_D();				\
	VAR_DST = read_##SIZE_##MEM_D(EA_DST);		\
	##OPER(SIZE, REG_S, VAR_DST);				\
	write_##SIZE_##MEM_D(EA_DST, VAR_DST)

#define EAM_MR_X(OPER, SIZE, MEM_S, REG_D)		\
	VAR_SRC = OPER_##SIZE_##MEM_S();			\
	##OPER(SIZE, VAR_SRC, REG_D)

#define EAM_MM_R(OPER, SIZE, MEM_S, MEM_D)		\
	VAR_SRC = OPER_##SIZE_##MEM_S();			\
	VAR_DST = OPER_##SIZE_##MEM_D();			\
	##OPER(SIZE, VAR_SRC, VAR_DST)

#define EAM_MM_W(OPER, SIZE, MEM_S, MEM_D)		\
	VAR_SRC = OPER_##SIZE_##MEM_S();			\
	EA_DST  = EA_##SIZE_##MEM_D();				\
	VAR_DST = read_##SIZE_##MEM_D(EA_DST);		\
	##OPER(SIZE, VAR_SRC, VAR_DST);				\
	write_##SIZE_##MEM_D(EA_DST, VAR_DST)


#define OP_AAA(A, B, C)														\
	if(FLAG_A || ((REG_AL&15)> 9))											\
	{																		\
		REG_AL = (REG_AL+6)&15);											\
		REG_AH++;															\
		FLAG_A = AFLAG_SET;													\
		FLAG_C = CFLAG_SET;													\
	}

#define OP_AAD(A, B, C)														\
	REG_AL += REG_AH*10;													\
	REG_AH = 0;																\
	FLAG_Z = REG_P = REG_AX;												\
	FLAG_S = 0

#define OP_AAM(A, B, C)														\
	REG_AH = AL / 10;														\
	REG_AL = AL % 10;														\
	FLAG_Z = REG_P = REG_AX;												\
	FLAG_S = SFLAG_16(REG_AX)

#define OP_AAS(A, B, C)														\
	if(FLAG_A || ((REG_AL&15)> 9))											\
	{																		\
		REG_AL -= 6;														\
		REG_AH--;															\
		FLAG_A = AFLAG_SET;													\
		FLAG_C = CFLAG_SET;													\
	}

#define OP_ADC(SIZE, SRC, DST)												\
	FLAG_Z = DST + SRC + CFLAG_AS_1();										\
	FLAG_A = MAKE_UINT_4(DST) + MAKE_UINT_4(SRC);							\
	FLAG_C = CFLAG_##SIZE(FLAG_Z);											\
	FLAG_S = SFLAG_##SIZE(FLAG_Z);											\
	FLAG_O = OFLAG_ADD_##SIZE(SRC, DST, FLAG_Z);							\
	FLAG_P = DST = FLAG_Z = MAKE_UINT_##SIZE(FLAG_Z)

#define OP_ADD(SIZE, SRC, DST)												\
	FLAG_Z = DST + SRC;														\
	FLAG_A = MAKE_UINT_4(DST) + MAKE_UINT_4(SRC);							\
	FLAG_C = CFLAG_##SIZE(FLAG_Z);											\
	FLAG_S = SFLAG_##SIZE(FLAG_Z);											\
	FLAG_O = OFLAG_ADD_##SIZE(SRC, DST, FLAG_Z);							\
	FLAG_P = DST = FLAG_Z = MAKE_UINT_##SIZE(FLAG_Z)

#define OP_AND(SIZE, SRC, DST)												\
	FLAG_P = FLAG_Z = DST &= SRC;											\
	FLAG_S = SFLAG_##SIZE(DST);												\
	FLAG_A = FLAG_C = FLAG_O = 0

BOUND (186)

CALL

#define OP_CBW(A, B, C)														\
	REG_AX = MAKE_INT_8(REG_AL)

#define OP_CLC(A, B, C)														\
	FLAG_C = CFLAG_CLEAR

#define OP_CLD(A, B, C)														\
	FLAG_D = DFLAG_CLEAR

#define OP_CLI(A, B, C)														\
	FLAG_I = IFLAG_CLEAR

#define OP_CMC(A, B, C)														\
	FLAG_C = ~FLAG_C

#define OP_CMP(SIZE, SRC, DST)												\
	FLAG_Z = DST - SRC;														\
	FLAG_A = MAKE_UINT_4(DST) - MAKE_UINT_4(SRC);							\
	FLAG_C = CFLAG_##SIZE(FLAG_Z);											\
	FLAG_S = SFLAG_##SIZE(FLAG_Z);											\
	FLAG_O = OFLAG_SUB_##SIZE(SRC, DST, FLAG_Z);							\
	FLAG_P = FLAG_Z = MAKE_UINT_##SIZE(FLAG_Z)

CMPS

#define OP_CWD(A, B, C)														\
	REG_D = MAKE_UINT_32(MAKE_INT_16(REG_A))>>16

/* Note: V undefined, but probably is affected by adder circuit */
#define OP_DAA(A, B, C)														\
	VAR_DST = REG_AL;														\
	VAR_SRC = daa_table[REG_AL | (FLAG_C&0x100) | ((FLAG_A<<5)&0x200)];		\
	FLAG_A = MAKE_UINT_4(REG_AL) + MAKE_UINT_4(VAR_SRC);					\
	FLAG_S = MAKE_UINT_8(REG_AL) + VAR_SRC;									\
	FLAG_C |= FLAG_S;														\
	FLAG_O = OFLAG_ADD_8(VAR_SRC, VAR_DST, FLAG_S);							\
	REG_AL = FLAG_P = FLAG_N = FLAG_Z = MAKE_UINT_8(FLAG_S)

/* Note: V undefined, but probably is affected by sub circuit */
#define OP_DAS(A, B, C)														\
	VAR_DST = REG_AL;														\
	VAR_SRC = daa_table[REG_AL | (FLAG_C&0x100) | ((FLAG_A<<5)&0x200)];		\
	FLAG_A = MAKE_UINT_4(REG_AL) - MAKE_UINT_4(VAR_SRC);					\
	FLAG_S = MAKE_UINT_8(REG_AL) - VAR_SRC;									\
	FLAG_C |= FLAG_S;														\
	FLAG_O = OFLAG_SUB_8(VAR_SRC, VAR_DST, FLAG_S);							\
	REG_AL = FLAG_P = FLAG_N = FLAG_Z = MAKE_UINT_8(FLAG_S)

#define OP_DEC(SIZE, B, DST)												\
	FLAG_P = FLAG_Z = MAKE_UINT_##SIZE(DST-1);								\
	FLAG_A = MAKE_UINT_4(DST) - 1;											\
	FLAG_S = SFLAG_##SIZE(FLAG_Z);											\
	FLAG_O = OFLAG_SUB_##SIZE(SRC, DST, FLAG_Z);							\
	DST = FLAG_Z

#define OP_DIV_8(A, SRC, C)													\
	if(SRC != 0)															\
	{																		\
		VAR_DST = REG_AX;													\
		REG_AL = VAR_DST / SRC;												\
		REG_AH = VAR_DST % SRC;												\
		BREAKOUT;															\
	}																		\
	exception processing	
		push flags
		clear I
		clear T
		push SEG_C
		SEG_C = 2
		REG_IP = 0


#define OP_DIV_16(A, SRC, C)												\
	if(SRC != 0)															\
	{																		\
		VAR_DST = (REG_D<<16) | REG_AX;										\
		REG_A = VAR_DST / SRC;												\
		REG_D = VAR_DST % SRC;												\
		BREAKOUT;															\
	}																		\
	exception processing	

ENTER (186)

ESC

IDIV

#define OP_HLT(A, B, C)														\
	STATE_HALTED |= HALT_HLT

#define OP_IMUL_8(A, SRC, C)												\
	REG_AX = MAKE_INT_8(REG_AL) * MAKE_INT_8(SRC);							\
	FLAG_O = (MAKE_INT_8(REG_AL) == REG_AX) << 7;							\
	FLAG_C = FLAG_O << 1

#define OP_IMUL_16(A, SRC, C)												\
	VAR_DST = MAKE_INT_16(REG_AX) * MAKE_INT_16(SRC);						\
	FLAG_O = (MAKE_INT_16(REG_AX) == VAR_DST) << 7;							\
	FLAG_C = FLAG_O << 1;													\
	REG_DX = MAKE_UINT_16(VAR_DST >> 16);									\
	REG_AX = VAR_DST

#define OP_IN(A, PORT, REG)													\
	REG = port_read(PORT)

#define OP_INC(SIZE, B, DST)												\
	FLAG_P = FLAG_Z = MAKE_UINT_##SIZE(DST+1);								\
	FLAG_A = MAKE_UINT_4(DST) + 1;											\
	FLAG_S = SFLAG_##SIZE(FLAG_Z);											\
	FLAG_O = OFLAG_ADD_##SIZE(SRC, DST, FLAG_Z);							\
	DST = FLAG_Z

INS

#define OP_INT(A, B, C)														\
	start_exception(OPER_IMM())

#define OP_INTO(A, B, C)													\
	start_exception(VECTOR_OVERFLOW)

#define OP_IRET(A, B, C)													\
	pull_regs()

#define OP_JCC(COND)														\
	if(COND())																\
		branch(OPER_IMM())

JMP

#define OP_LAHF(A, B, C)													\
	REG_AH = get_ccr()

LDS

LEA

LEAVE

LES

LOCK

LODS

#define OP_LOOP()
	if(--REG_CX)
		branch(OPER_IMM())

#define LOOPCC(COND)
	if(--REG_CX && COND())
		branch(OPER_IMM())

#define OP_MOV(SIZE, SRC, DST)
	DST = SRC

OP_MOV

MOVS

#define OP_MUL_8(A, SRC, C)												\
	REG_AX = REG_AL * SRC;												\
	FLAG_O = (REG_AH != 0) << 7;										\
	FLAG_C = FLAG_O << 1

#define OP_MUL_16(A, SRC, C)												\
	VAR_DST = REG_AX * SRC;													\
	REG_DX = MAKE_UINT_16(VAR_DST >> 16);									\
	REG_AX = VAR_DST;														\
	FLAG_O = (REG_DX != 0) << 7;											\
	FLAG_C = FLAG_O << 1


#define OP_NEG(SIZE, B, DST)												\
	FLAG_Z = -DST;															\
	FLAG_A = 0 - MAKE_UINT_4(DST);											\
	FLAG_C = CFLAG_##SIZE(FLAG_Z);											\
	FLAG_S = SFLAG_##SIZE(FLAG_Z);											\
	FLAG_O = OFLAG_SUB_##SIZE(SRC, DST, FLAG_Z);							\
	FLAG_P = DST = FLAG_Z = MAKE_UINT_##SIZE(FLAG_Z)

#define OP_NOP()

#define OP_NOT(SIZE, B, DST)												\
	DST = MAKE_UINT_##SIZE(~DST)

#define OP_OR(SIZE, SRC, DST)												\
	FLAG_P = FLAG_Z = DST |= SRC;											\
	FLAG_S = SFLAG_##SIZE(DST);												\
	FLAG_A = FLAG_C = FLAG_O = 0

#define OP_OUT(A, PORT, REG)													\
	port_write(PORT, REG)

OUTS

#define OP_POP(A, B, DST)													\
	DST = pop_16()

#define OP_POPA()
	REG_DI = pop_16();
	REG_SI = pop_16();
	REG_BP = pop_16();
	pop_16();
	REG_BX = pop_16();
	REG_DX = pop_16();
	REG_CX = pop_16();
	REG_AX = pop_16();

#define OP_POPF()
	set_flags(pop_16())

#define OP_PUSH(A, SRC, C)
	push_16(SRC)

#define OP_PUSHA()
	push_16(REG_AX);
	push_16(REG_CX);
	push_16(REG_DX);
	push_16(REG_BX);
	push_16(REG_SP-8);
	push_16(REG_BP);
	push_16(REG_SI);
	push_16(REG_DI);

#define OP_PUSHF()
	push_16(get_flags())

#define LSL(A, C)    ((A) << (C))
#define LSR(A, C)    ((A) >> (C))
#define ROL_8(A, C)  (LSL(A, C) | LSR(A, 8-(C)))
#define ROL_9(A, C)  (LSL(A, C) | LSR(A, 9-(C)))
#define ROL_16(A, C) (LSL(A, C) | LSR(A, 16-(C)))
#define ROL_17(A, C) (LSL(A, C) | LSR(A, 17-(C)))

#define OP_RCL_8(A, COUNT, DST)
	FLAG_C = (FLAG_C&0x100) | DST;
	FLAG_C = ROL_9(FLAG_C, COUNT % 9);
	FLAG_O = FLAG_C ^ (FLAG_C>>1);
	DST = MAKE_UINT_8(FLAG_C)

#define OP_RCL_16(A, COUNT, DST)
	FLAG_C = ((FLAG_C&0x100)<<8) | DST;
	FLAG_C = ROL_17(FLAG_C, COUNT % 17);
	FLAG_O = OFLAG_16(FLAG_C ^ (FLAG_C>>1));
	DST = MAKE_UINT_16(FLAG_C);
	FLAG_C = CFLAG_16(FLAG_C)

#define OP_RCR_8(A, COUNT, DST)
	FLAG_C = (FLAG_C&0x100) | DST;
	FLAG_C = ROR_9(FLAG_C, COUNT % 9);
	DST = MAKE_UINT_8(FLAG_C);
	FLAG_O = DST ^ (DST<<1)

#define OP_RCR_16(A, COUNT, DST)
	FLAG_C = ((FLAG_C&0x100)<<8) | DST;
	FLAG_C = ROR_17(FLAG_C, COUNT % 17);
	DST = MAKE_UINT_16(FLAG_C);
	FLAG_C = CFLAG_16(FLAG_C);
	FLAG_O = OFLAG_16(DST ^ (DST<<1))

REPCC

RET

#define OP_ROL(SIZE, COUNT, DST)
	FLAG_C = ROL_##SIZE(DST, COUNT&(##SIZE-1));
	FLAG_O = FLAG_C ^ (FLAG_C>>1);
	DST = MAKE_UINT_##SIZE(FLAG_C)

ROR

#define OP_SAFH()
	set_flags(REG_AL)

SHL

SAL

SAR




186 only:

psha
popa
ins
outs
enter
leave
bound

186 enhanced:
push
imul
sal
shl
sar
shr
rol
ror
rcl
rcr


r/m
000 (BX) + (SI) + DISP
001 (BX) + (DI) + DISP
010 (BP) + (SI) + DISP
011 (BP) + (DI) + DISP
100        (SI) + DISP
101        (DI) + DISP
110 (BP)        + DISP if mod != 00, disp-high:disp-low if mod = 00
111 (BX)        + DISP

mod
00  if r/m != 110 disp = 0, disp-low and disp-high are absent.
    if r/m = 110, EA = disp-high:disp-low
01  DISP - disp-low, sign extended to 16 bits. disp-high is absent
10  DISP = disp-high:disp-low
11  r/m is register

reg    byte    word
000    AL      AX
001    CL      CX
010    DL      DX
011    BL      BX
100    AH      SP
101    CH      BP
110    DH      SI
111    BH      DI

ttt
000 ROL
001 ROR
010 RCL
011 RCR
100 SHL/SAL
101 SHR
110 -
111 SAR


common: mod, reg, r/m
